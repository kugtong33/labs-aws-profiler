#!/usr/bin/env bash
#
# awsprof - AWS Profile Manager
# https://github.com/ubuntu/labs-aws-profiler
#

# Only set strict mode when running as script, not when sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    set -euo pipefail
fi

#=== CONFIGURATION ===
_awsprof_version="1.0.0"
_awsprof_credentials="${AWS_SHARED_CREDENTIALS_FILE:-$HOME/.aws/credentials}"
_awsprof_config="${AWS_CONFIG_FILE:-$HOME/.aws/config}"
AWSPROF_EMOJI="${AWSPROF_EMOJI:-0}"

#=== OUTPUT UTILITIES ===
# awsprof_msg - Output message to stderr
# awsprof_error - Output error message to stderr
# awsprof_warn - Output warning message to stderr
# awsprof_success - Output success message to stderr

awsprof_msg() {
    echo "$*" >&2
}

awsprof_error() {
    awsprof_msg "Error: $*"
}

awsprof_warn() {
    awsprof_msg "Warning: $*"
}

awsprof_success() {
    awsprof_msg "$*"
}

#=== INI HANDLING ===
# awsprof_ini_list_sections - List all profile sections from credentials file
# awsprof_ini_read_section - Read key-value pairs from a specific section

awsprof_ini_list_sections() {
    local file="${1:-$_awsprof_credentials}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Extract section names using awk
    local errexit_was_set=0
    [[ $- == *e* ]] && errexit_was_set=1
    set +e
    awk '
        /^\[/ {
            if ($0 !~ /^\[[^][]+\]$/) {
                print "Error: Malformed INI section header at line " NR ": " $0 > "/dev/stderr"
                exit 2
            }
            gsub(/^\[|\]$/, "")
            print
        }
    ' "$file"
    local awk_status=$?
    if [[ $errexit_was_set -eq 1 ]]; then
        set -e
    fi
    if [[ $awk_status -ne 0 ]]; then
        if [[ $awk_status -ne 2 ]]; then
            awsprof_error "Failed to parse credentials file: $file"
        fi
        return 1
    fi

    return 0
}

awsprof_ini_read_section() {
    local section="$1"
    local file="${2:-$_awsprof_credentials}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        return 1
    fi

    # Read section content using awk
    local errexit_was_set=0
    [[ $- == *e* ]] && errexit_was_set=1
    set +e
    awk -F' *= *' -v section="[$section]" '
        /^\[/ {
            if ($0 !~ /^\[[^][]+\]$/) {
                print "Error: Malformed INI section header at line " NR ": " $0 > "/dev/stderr"
                exit 2
            }
            found = ($0 == section)
            next
        }
        found && $0 !~ /^[ \t]*($|[;#])/ && index($0, "=") == 0 {
            print "Error: Malformed INI key/value at line " NR ": " $0 > "/dev/stderr"
            exit 2
        }
        found && /^[^#;]/ && NF >= 2 {
            key = $1
            gsub(/^[ \t]+|[ \t]+$/, "", key)
            val = $2
            for (i = 3; i <= NF; i++) val = val "=" $i
            gsub(/^[ \t]+|[ \t]+$/, "", val)
            print key "=" val
        }
    ' "$file"
    local awk_status=$?
    if [[ $errexit_was_set -eq 1 ]]; then
        set -e
    fi
    if [[ $awk_status -ne 0 ]]; then
        if [[ $awk_status -ne 2 ]]; then
            awsprof_error "Failed to read section '$section' from: $file"
        fi
        return 1
    fi

    return 0
}

#=== FILE OPERATIONS ===
# awsprof_backup_credentials - Create timestamped backup of credentials file
# awsprof_ini_write_section - Write or update a section in INI file
# awsprof_ini_delete_section - Delete a section from INI file

awsprof_backup_credentials() {
    # Use AWS_SHARED_CREDENTIALS_FILE if set, otherwise default
    local file="${1:-${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Generate timestamp in YYYYMMDD-HHMMSS format
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_file="${file}.bak.${timestamp}"

    # Copy to backup
    if ! cp "$file" "$backup_file" 2>/dev/null; then
        awsprof_error "Failed to create backup: $backup_file"
        return 1
    fi

    return 0
}

awsprof_ini_write_section() {
    local section="$1"
    shift
    local kvpairs=("$@")

    local file="${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}"
    local temp_file=$(mktemp)

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        rm -f "$temp_file"
        return 1
    fi

    # Create backup if file exists
    if [[ -f "$file" ]]; then
        awsprof_backup_credentials "$file" || {
            rm -f "$temp_file"
            return 1
        }
    fi

    # Build awk script for section write
    local awk_script='
    BEGIN {
        section_header = "[" section "]"
        found = 0
        in_target = 0
        split(kvpairs, pairs, "\n")
    }
    /^\[/ {
        # If we were in target section, output new key-value pairs
        if (in_target && found == 1) {
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
            found = 2  # Mark as already written
        }
        # Check if this is our target section
        in_target = ($0 == section_header)
        if (!in_target) print
        if (in_target) print
        next
    }
    # Skip old key-value pairs in target section
    in_target && /^[a-zA-Z_]/ {
        next
    }
    # Print everything else
    !in_target {
        print
    }
    END {
        # If section was found but keys not yet written, write them
        if (found == 1 && in_target) {
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
        }
        # If section was never found, append it
        if (found == 0) {
            print ""
            print section_header
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
        }
    }
    '

    # Convert kvpairs array to newline-separated string
    local kvpairs_str=""
    for pair in "${kvpairs[@]}"; do
        kvpairs_str="${kvpairs_str}${pair}"$'\n'
    done

    # Run awk to create new file content
    if [[ -f "$file" ]]; then
        awk -v section="$section" -v kvpairs="$kvpairs_str" "$awk_script" "$file" > "$temp_file"
    else
        # Create new file with section
        echo "[$section]" > "$temp_file"
        for pair in "${kvpairs[@]}"; do
            echo "$pair" >> "$temp_file"
        done
    fi

    # Atomic move and set permissions
    if ! mv "$temp_file" "$file" 2>/dev/null; then
        awsprof_error "Failed to write credentials file: $file"
        rm -f "$temp_file"
        return 1
    fi

    if ! chmod 600 "$file" 2>/dev/null; then
        awsprof_error "Failed to set permissions on: $file"
        return 1
    fi

    return 0
}

awsprof_ini_delete_section() {
    local section="$1"
    local file="${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}"
    local temp_file=$(mktemp)

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        rm -f "$temp_file"
        return 1
    fi

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        rm -f "$temp_file"
        return 1
    fi

    # Create backup
    awsprof_backup_credentials "$file" || {
        rm -f "$temp_file"
        return 1
    }

    # Awk script to remove section
    # Delete section header and its key=value lines
    # Stop deleting when we hit a blank line, comment, or next section
    awk -v section="[$section]" '
        BEGIN { in_target = 0 }
        /^\[/ {
            # Check if this is the target section
            in_target = ($0 == section)
            if (!in_target) print
            next
        }
        # If in target section and it is a key=value line, skip it
        in_target && /^[a-zA-Z_].*=/ {
            next
        }
        # If in target and it is blank or comment, stop deleting and print
        in_target && (/^$/ || /^[;#]/) {
            in_target = 0
            print
            next
        }
        # If not in target, print everything
        !in_target {
            print
        }
    ' "$file" > "$temp_file"

    # Atomic move and set permissions
    if ! mv "$temp_file" "$file" 2>/dev/null; then
        awsprof_error "Failed to write credentials file: $file"
        rm -f "$temp_file"
        return 1
    fi

    if ! chmod 600 "$file" 2>/dev/null; then
        awsprof_error "Failed to set permissions on: $file"
        return 1
    fi

    return 0
}

#=== PROFILE COMMANDS ===
# awsprof_cmd_list - List available profiles
# awsprof_cmd_use - Switch to a profile
# awsprof_cmd_whoami - Show current profile
# awsprof_cmd_add - Add a new profile

awsprof_cmd_list() {
    local profiles
    profiles=$(awsprof_ini_list_sections) || return 1

    if [[ -z "$profiles" ]]; then
        awsprof_msg "No profiles found"
        return 0
    fi

    echo "$profiles"
    return 0
}

awsprof_cmd_use() {
    local profile_name="$1"

    # Validate parameter provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof use <profile-name>"
        return 1
    fi

    # Validate profile exists
    local profiles
    profiles=$(awsprof_ini_list_sections) || return 1

    if ! echo "$profiles" | grep -qx "$profile_name"; then
        awsprof_error "Profile '$profile_name' not found"
        return 1
    fi

    # Output eval code to stdout
    echo "export AWS_PROFILE=$profile_name"

    # Output success message to stderr
    awsprof_success "Switched to profile: $profile_name"

    return 0
}

awsprof_cmd_whoami() {
    # Check if AWS_PROFILE is set and non-empty
    if [[ -n "${AWS_PROFILE:-}" ]]; then
        # Output current profile to stdout
        echo "$AWS_PROFILE"
    else
        # Output default message to stdout
        echo "No profile set (using default)"
    fi

    return 0
}

awsprof_cmd_add() {
    local profile_name="$1"

    # Validate profile name provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof add <profile-name>"
        return 1
    fi

    # Check if profile already exists
    local profiles
    profiles=$(awsprof_ini_list_sections 2>/dev/null) || profiles=""
    if echo "$profiles" | grep -qx "$profile_name"; then
        awsprof_error "Profile '$profile_name' already exists. Use 'awsprof edit' to modify."
        return 1
    fi

    # Prompt for credentials
    awsprof_msg "Adding new profile: $profile_name"
    local access_key_id
    local secret_access_key
    read -p "AWS Access Key ID: " access_key_id
    read -s -p "AWS Secret Access Key: " secret_access_key
    echo  # Newline after hidden input

    # Validate credentials are not empty
    if [[ -z "$access_key_id" ]] || [[ -z "$secret_access_key" ]]; then
        awsprof_error "Access Key ID and Secret Access Key are required"
        return 1
    fi

    # Basic format validation (AWS access keys typically start with AKIA)
    if [[ ! "$access_key_id" =~ ^AK[A-Z0-9]{18}$ ]]; then
        awsprof_warn "Access Key ID format may be invalid (expected AKIA... format)"
    fi

    # Write profile using Story 2.1 function
    if ! awsprof_ini_write_section "$profile_name" \
        "aws_access_key_id=$access_key_id" \
        "aws_secret_access_key=$secret_access_key"; then
        awsprof_error "Failed to add profile"
        return 1
    fi

    # Success message
    awsprof_success "Profile '$profile_name' added successfully"

    return 0
}

# awsprof_cmd_edit - Edit an existing profile
awsprof_cmd_edit() {
    local profile_name="$1"

    # Validate profile name provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof edit <profile-name>"
        return 1
    fi

    # Check if profile exists
    local profiles
    profiles=$(awsprof_ini_list_sections 2>/dev/null) || profiles=""
    if ! echo "$profiles" | grep -qx "$profile_name"; then
        awsprof_error "Profile '$profile_name' not found"
        return 1
    fi

    # Prompt for credentials
    awsprof_msg "Editing profile: $profile_name"
    local access_key_id
    local secret_access_key
    read -p "AWS Access Key ID: " access_key_id
    read -s -p "AWS Secret Access Key: " secret_access_key
    echo  # Newline after hidden input

    # Validate credentials are not empty
    if [[ -z "$access_key_id" ]] || [[ -z "$secret_access_key" ]]; then
        awsprof_error "Access Key ID and Secret Access Key are required"
        return 1
    fi

    # Basic format validation (AWS access keys typically start with AKIA)
    if [[ ! "$access_key_id" =~ ^AK[A-Z0-9]{18}$ ]]; then
        awsprof_warn "Access Key ID format may be invalid (expected AKIA... format)"
    fi

    # Write profile using Story 2.1 function
    if ! awsprof_ini_write_section "$profile_name" \
        "aws_access_key_id=$access_key_id" \
        "aws_secret_access_key=$secret_access_key"; then
        awsprof_error "Failed to update profile"
        return 1
    fi

    # Success message
    awsprof_success "Profile '$profile_name' updated successfully"

    return 0
}

#=== MAIN DISPATCH ===
# Main command dispatcher

# If script is sourced (for testing), don't run main
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-}" in
        list)
            awsprof_cmd_list
            exit $?
            ;;
        use)
            awsprof_cmd_use "${2:-}"
            exit $?
            ;;
        whoami)
            awsprof_cmd_whoami
            exit $?
            ;;
        add)
            awsprof_cmd_add "${2:-}"
            exit $?
            ;;
        edit)
            awsprof_cmd_edit "${2:-}"
            exit $?
            ;;
        help|--help|-h|"")
            awsprof_msg "awsprof v${_awsprof_version}"
            awsprof_msg "Usage: awsprof <command>"
            awsprof_msg ""
            awsprof_msg "Commands:"
            awsprof_msg "  list              List available AWS profiles"
            awsprof_msg "  use <profile>     Switch to a profile (use with eval)"
            awsprof_msg "  whoami            Show currently active profile"
            awsprof_msg "  add <profile>     Add a new AWS profile"
            awsprof_msg "  edit <profile>    Edit an existing AWS profile"
            exit 0
            ;;
        *)
            awsprof_error "Unknown command: ${1}"
            exit 1
            ;;
    esac
fi
