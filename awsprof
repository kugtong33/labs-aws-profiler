#!/usr/bin/env bash
#
# awsprof - AWS Profile Manager
# https://github.com/ubuntu/labs-aws-profiler
#

# Only set strict mode when running as script, not when sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    set -euo pipefail
fi

#=== CONFIGURATION ===
_awsprof_version="1.0.0"
_awsprof_credentials="${AWS_SHARED_CREDENTIALS_FILE:-$HOME/.aws/credentials}"
_awsprof_config="${AWS_CONFIG_FILE:-$HOME/.aws/config}"
AWSPROF_EMOJI="${AWSPROF_EMOJI:-0}"

#=== OUTPUT UTILITIES ===
# awsprof_msg - Output message to stderr
# awsprof_error - Output error message to stderr
# awsprof_warn - Output warning message to stderr
# awsprof_success - Output success message to stderr

awsprof_msg() {
    echo "$*" >&2
}

awsprof_error() {
    awsprof_msg "Error: $*"
}

awsprof_warn() {
    awsprof_msg "Warning: $*"
}

awsprof_success() {
    awsprof_msg "$*"
}

#=== INI HANDLING ===
# awsprof_ini_list_sections - List all profile sections from credentials file
# awsprof_ini_read_section - Read key-value pairs from a specific section

awsprof_ini_list_sections() {
    local file="${1:-$_awsprof_credentials}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Extract section names using awk
    local errexit_was_set=0
    [[ $- == *e* ]] && errexit_was_set=1
    set +e
    awk '
        /^\[/ {
            if ($0 !~ /^\[[^][]+\]$/) {
                print "Error: Malformed INI section header at line " NR ": " $0 > "/dev/stderr"
                exit 2
            }
            gsub(/^\[|\]$/, "")
            print
        }
    ' "$file"
    local awk_status=$?
    if [[ $errexit_was_set -eq 1 ]]; then
        set -e
    fi
    if [[ $awk_status -ne 0 ]]; then
        if [[ $awk_status -ne 2 ]]; then
            awsprof_error "Failed to parse credentials file: $file"
        fi
        return 1
    fi

    return 0
}

awsprof_ini_read_section() {
    local section="$1"
    local file="${2:-$_awsprof_credentials}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        return 1
    fi

    # Read section content using awk
    local errexit_was_set=0
    [[ $- == *e* ]] && errexit_was_set=1
    set +e
    awk -F' *= *' -v section="[$section]" '
        /^\[/ {
            if ($0 !~ /^\[[^][]+\]$/) {
                print "Error: Malformed INI section header at line " NR ": " $0 > "/dev/stderr"
                exit 2
            }
            found = ($0 == section)
            next
        }
        found && $0 !~ /^[ \t]*($|[;#])/ && index($0, "=") == 0 {
            print "Error: Malformed INI key/value at line " NR ": " $0 > "/dev/stderr"
            exit 2
        }
        found && /^[^#;]/ && NF >= 2 {
            key = $1
            gsub(/^[ \t]+|[ \t]+$/, "", key)
            val = $2
            for (i = 3; i <= NF; i++) val = val "=" $i
            gsub(/^[ \t]+|[ \t]+$/, "", val)
            print key "=" val
        }
    ' "$file"
    local awk_status=$?
    if [[ $errexit_was_set -eq 1 ]]; then
        set -e
    fi
    if [[ $awk_status -ne 0 ]]; then
        if [[ $awk_status -ne 2 ]]; then
            awsprof_error "Failed to read section '$section' from: $file"
        fi
        return 1
    fi

    return 0
}

#=== FILE OPERATIONS ===
# awsprof_backup_credentials - Create timestamped backup of credentials file
# awsprof_ini_write_section - Write or update a section in INI file
# awsprof_ini_delete_section - Delete a section from INI file

awsprof_backup_credentials() {
    # Use AWS_SHARED_CREDENTIALS_FILE if set, otherwise default
    local file="${1:-${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Generate timestamp in YYYYMMDD-HHMMSS format
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_file="${file}.bak.${timestamp}"

    # Copy to backup
    if ! cp "$file" "$backup_file" 2>/dev/null; then
        awsprof_error "Failed to create backup: $backup_file"
        return 1
    fi

    return 0
}

awsprof_ini_write_section() {
    local section="$1"
    shift
    local kvpairs=("$@")

    local file="${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}"

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        return 1
    fi

    local dir
    dir=$(dirname "$file")
    local temp_file
    temp_file=$(mktemp -p "$dir" ".awsprof.XXXXXX") || {
        awsprof_error "Failed to create temp file in: $dir"
        return 1
    }

    local crlf=0
    if [[ -f "$file" ]] && LC_ALL=C grep -q $'\r' "$file"; then
        crlf=1
    fi

    # Build awk script for section write
    local awk_script='
    BEGIN {
        section_header = "[" section "]"
        in_target = 0
        found = 0
        wrote = 0
        split(kvpairs, pairs, "\n")
    }
    /^\[/ {
        # If we were in target section, output new key-value pairs
        if (in_target && wrote == 0) {
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
            wrote = 1
        }
        # Check if this is our target section
        in_target = ($0 == section_header)
        if (in_target) {
            found = 1
            print
        } else {
            print
        }
        next
    }
    # Skip old key-value pairs in target section
    in_target {
        if ($0 ~ /^[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*=/) next
        print
        next
    }
    # Print everything else
    { print }
    END {
        # If section was never found, append it
        if (found == 0) {
            print ""
            print section_header
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
        } else if (found == 1 && wrote == 0) {
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
        }
    }
    '

    # Convert kvpairs array to newline-separated string
    local kvpairs_str=""
    for pair in "${kvpairs[@]}"; do
        kvpairs_str="${kvpairs_str}${pair}"$'\n'
    done

    # Run awk to create new file content
    if [[ -f "$file" ]]; then
        if ! awk -v section="$section" -v kvpairs="$kvpairs_str" "$awk_script" "$file" > "$temp_file"; then
            awsprof_error "Failed to write section '$section' to temp file"
            rm -f "$temp_file"
            return 1
        fi
    else
        # Create new file with section
        echo "[$section]" > "$temp_file"
        for pair in "${kvpairs[@]}"; do
            echo "$pair" >> "$temp_file"
        done
    fi

    if [[ $crlf -eq 1 ]]; then
        if ! sed -e 's/\r$//' -e 's/$/\r/' "$temp_file" > "${temp_file}.crlf"; then
            awsprof_error "Failed to normalize CRLF line endings"
            rm -f "$temp_file" "${temp_file}.crlf"
            return 1
        fi
        mv "${temp_file}.crlf" "$temp_file" || {
            awsprof_error "Failed to update temp file with CRLF"
            rm -f "$temp_file" "${temp_file}.crlf"
            return 1
        }
    fi

    if ! chmod 600 "$temp_file" 2>/dev/null; then
        awsprof_error "Failed to set permissions on temp file"
        rm -f "$temp_file"
        return 1
    fi

    # Create backup if file exists
    if [[ -f "$file" ]]; then
        awsprof_backup_credentials "$file" || {
            rm -f "$temp_file"
            return 1
        }
    fi

    # Atomic move
    if ! mv "$temp_file" "$file" 2>/dev/null; then
        awsprof_error "Failed to write credentials file: $file"
        rm -f "$temp_file"
        return 1
    fi

    return 0
}

awsprof_ini_delete_section() {
    local section="$1"
    local file="${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}"

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        return 1
    fi

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        rm -f "$temp_file"
        return 1
    fi

    local dir
    dir=$(dirname "$file")
    local temp_file
    temp_file=$(mktemp -p "$dir" ".awsprof.XXXXXX") || {
        awsprof_error "Failed to create temp file in: $dir"
        return 1
    }

    local crlf=0
    if LC_ALL=C grep -q $'\r' "$file"; then
        crlf=1
    fi

    # Awk script to remove section
    # Delete section header and its key=value lines
    if ! awk -v section="[$section]" '
        BEGIN { in_target = 0; seen_kv = 0 }
        /^\[/ {
            if ($0 == section) {
                in_target = 1
                seen_kv = 0
                next
            }
            in_target = 0
            seen_kv = 0
            print
            next
        }
        in_target {
            if ($0 ~ /^[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*=/) {
                seen_kv = 1
                next
            }
            if ($0 ~ /^$/ || $0 ~ /^[;#]/) {
                if (seen_kv == 1) {
                    in_target = 0
                    print
                }
                next
            }
            next
        }
        { print }
    ' "$file" > "$temp_file"; then
        awsprof_error "Failed to delete section '$section' to temp file"
        rm -f "$temp_file"
        return 1
    fi

    if [[ $crlf -eq 1 ]]; then
        if ! sed -e 's/\r$//' -e 's/$/\r/' "$temp_file" > "${temp_file}.crlf"; then
            awsprof_error "Failed to normalize CRLF line endings"
            rm -f "$temp_file" "${temp_file}.crlf"
            return 1
        fi
        mv "${temp_file}.crlf" "$temp_file" || {
            awsprof_error "Failed to update temp file with CRLF"
            rm -f "$temp_file" "${temp_file}.crlf"
            return 1
        }
    fi

    if ! chmod 600 "$temp_file" 2>/dev/null; then
        awsprof_error "Failed to set permissions on temp file"
        rm -f "$temp_file"
        return 1
    fi

    # Create backup
    awsprof_backup_credentials "$file" || {
        rm -f "$temp_file"
        return 1
    }

    # Atomic move
    if ! mv "$temp_file" "$file" 2>/dev/null; then
        awsprof_error "Failed to write credentials file: $file"
        rm -f "$temp_file"
        return 1
    fi

    return 0
}

#=== UTILITY FUNCTIONS ===
# awsprof_util_read_awsprofile - Read .awsprofile file from current directory

awsprof_util_read_awsprofile() {
    local profile_file="./.awsprofile"

    # Check if file exists
    if [[ ! -f "$profile_file" ]]; then
        return 0  # Return empty/success for missing file (silent failure)
    fi

    # Read first non-empty line, trim whitespace, and output to stdout
    # Use awk to handle whitespace trimming and ignore empty lines
    awk 'NF {print; exit}' "$profile_file" | awk '{gsub(/^[[:space:]]+|[[:space:]]+$/, ""); print}'

    return 0
}

#=== PROFILE COMMANDS ===
# awsprof_cmd_list - List available profiles
# awsprof_cmd_use - Switch to a profile
# awsprof_cmd_whoami - Show current profile
# awsprof_cmd_add - Add a new profile
# awsprof_cmd_edit - Edit an existing profile
# awsprof_cmd_remove - Remove an existing profile
# awsprof_cmd_import - Import profiles from existing credentials file

awsprof_cmd_list() {
    local profiles
    profiles=$(awsprof_ini_list_sections) || return 1

    if [[ -z "$profiles" ]]; then
        awsprof_msg "No profiles found"
        return 0
    fi

    echo "$profiles"
    return 0
}

awsprof_cmd_use() {
    local profile_name="$1"
    local extra_arg="$2"

    # Validate parameter provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof use <profile-name>"
        return 1
    fi

    # Reject if extra arguments provided
    if [[ -n "$extra_arg" ]]; then
        awsprof_error "Too many arguments: expected profile name only"
        awsprof_msg "Usage: awsprof use <profile-name>"
        return 1
    fi

    # Validate profile exists
    local profiles
    profiles=$(awsprof_ini_list_sections) || return 1

    if ! printf '%s\n' "$profiles" | grep -Fxq "$profile_name"; then
        awsprof_error "Profile '$profile_name' not found"
        return 1
    fi

    # Output eval code to stdout
    echo "export AWS_PROFILE=$profile_name"

    # Output success message to stderr
    awsprof_success "Switched to profile: $profile_name"

    return 0
}

awsprof_cmd_whoami() {
    # Check if AWS_PROFILE is set and non-empty
    if [[ -n "${AWS_PROFILE:-}" ]]; then
        # Output current profile to stdout
        echo "$AWS_PROFILE"
    else
        # Output default message to stdout
        echo "No profile set (using default)"
    fi

    return 0
}

awsprof_cmd_add() {
    local profile_name="$1"
    local extra_arg="$2"

    # Validate profile name provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof add <profile-name>"
        return 1
    fi

    # Reject if extra arguments provided
    if [[ -n "$extra_arg" ]]; then
        awsprof_error "Too many arguments: expected profile name only"
        awsprof_msg "Usage: awsprof add <profile-name>"
        return 1
    fi

    # Check if profile already exists
    local profiles
    if ! profiles=$(awsprof_ini_list_sections); then
        return 1
    fi
    if printf '%s\n' "$profiles" | grep -Fxq "$profile_name"; then
        awsprof_error "Profile '$profile_name' already exists. Use 'awsprof edit' to modify."
        return 1
    fi

    # Prompt for credentials
    awsprof_msg "Adding new profile: $profile_name"
    local access_key_id
    local secret_access_key
    read -p "AWS Access Key ID: " access_key_id
    read -s -p "AWS Secret Access Key: " secret_access_key
    printf '\n' >&2  # Newline after hidden input

    # Validate credentials are not empty
    if [[ -z "$access_key_id" ]] || [[ -z "$secret_access_key" ]]; then
        awsprof_error "Access Key ID and Secret Access Key are required"
        return 1
    fi

    # Basic format validation
    if [[ ! "$access_key_id" =~ ^(AKIA|ASIA)[A-Z0-9]{16}$ ]]; then
        awsprof_error "Invalid Access Key ID format"
        return 1
    fi
    if [[ ! "$secret_access_key" =~ ^[A-Za-z0-9/+=]{40}$ ]]; then
        awsprof_error "Invalid Secret Access Key format"
        return 1
    fi

    # Write profile using Story 2.1 function
    if ! awsprof_ini_write_section "$profile_name" \
        "aws_access_key_id=$access_key_id" \
        "aws_secret_access_key=$secret_access_key"; then
        awsprof_error "Failed to add profile"
        return 1
    fi

    # Success message
    awsprof_success "Profile '$profile_name' added successfully"

    return 0
}

# awsprof_cmd_edit - Edit an existing profile
awsprof_cmd_edit() {
    local profile_name="$1"
    local extra_arg="$2"

    # Validate profile name provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof edit <profile-name>"
        return 1
    fi

    # Reject if extra arguments provided
    if [[ -n "$extra_arg" ]]; then
        awsprof_error "Too many arguments: expected profile name only"
        awsprof_msg "Usage: awsprof edit <profile-name>"
        return 1
    fi

    # Check if profile exists
    local profiles
    if ! profiles=$(awsprof_ini_list_sections); then
        return 1
    fi
    if ! printf '%s\n' "$profiles" | grep -Fxq "$profile_name"; then
        awsprof_error "Profile '$profile_name' not found"
        return 1
    fi

    # Prompt for credentials
    awsprof_msg "Editing profile: $profile_name"
    local access_key_id
    local secret_access_key
    read -p "AWS Access Key ID: " access_key_id
    read -s -p "AWS Secret Access Key: " secret_access_key
    printf '\n' >&2  # Newline after hidden input

    # Validate credentials are not empty
    if [[ -z "$access_key_id" ]] || [[ -z "$secret_access_key" ]]; then
        awsprof_error "Access Key ID and Secret Access Key are required"
        return 1
    fi

    # Basic format validation
    if [[ ! "$access_key_id" =~ ^(AKIA|ASIA)[A-Z0-9]{16}$ ]]; then
        awsprof_error "Invalid Access Key ID format"
        return 1
    fi
    if [[ ! "$secret_access_key" =~ ^[A-Za-z0-9/+=]{40}$ ]]; then
        awsprof_error "Invalid Secret Access Key format"
        return 1
    fi

    # Write profile using Story 2.1 function
    if ! awsprof_ini_write_section "$profile_name" \
        "aws_access_key_id=$access_key_id" \
        "aws_secret_access_key=$secret_access_key"; then
        awsprof_error "Failed to update profile"
        return 1
    fi

    # Success message
    awsprof_success "Profile '$profile_name' updated successfully"

    return 0
}

# awsprof_cmd_remove - Remove an existing profile
awsprof_cmd_remove() {
    local profile_name="$1"
    local extra_arg="$2"

    # Validate profile name provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof remove <profile-name>"
        return 1
    fi

    # Reject if extra arguments provided
    if [[ -n "$extra_arg" ]]; then
        awsprof_error "Too many arguments: expected profile name only"
        awsprof_msg "Usage: awsprof remove <profile-name>"
        return 1
    fi

    # Check if profile exists
    local profiles
    if ! profiles=$(awsprof_ini_list_sections); then
        return 1
    fi
    if ! printf '%s\n' "$profiles" | grep -Fxq "$profile_name"; then
        awsprof_error "Profile '$profile_name' not found"
        return 1
    fi

    # Delete the profile using Story 2.1 function
    if ! awsprof_ini_delete_section "$profile_name"; then
        awsprof_error "Failed to remove profile"
        return 1
    fi

    # Success message
    awsprof_success "Profile '$profile_name' removed successfully"

    return 0
}

# awsprof_cmd_import - Import profiles from existing credentials file
awsprof_cmd_import() {
    local file="${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}"

    # Check if credentials file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "No credentials file found at $file"
        return 1
    fi

    # Get all profiles from credentials file (capture parse errors)
    local profiles
    local err_file
    err_file=$(mktemp) || {
        awsprof_error "Failed to create temp file for error capture"
        return 0
    }
    local list_status=0
    if profiles=$(awsprof_ini_list_sections "$file" 2>"$err_file"); then
        list_status=0
    else
        list_status=$?
    fi
    local parse_errors
    parse_errors=$(cat "$err_file" 2>/dev/null)
    rm -f "$err_file"

    # Count profiles and prepare output
    local profile_count
    if [[ -z "$profiles" ]]; then
        profile_count=0
    else
        profile_count=$(echo "$profiles" | wc -l)
    fi

    # Display results
    if [[ $profile_count -eq 0 ]]; then
        awsprof_msg "Found 0 profiles"
    else
        # Format profile list as space-separated string
        local profile_list
        profile_list=$(echo "$profiles" | tr '\n' ' ' | sed 's/ $//')
        awsprof_msg "Found $profile_count profiles: $profile_list"
        awsprof_success "All profiles are accessible to awsprof"
    fi

    if [[ $list_status -ne 0 ]] && [[ -n "$parse_errors" ]]; then
        awsprof_warn "Errors encountered while parsing credentials file:"
        awsprof_msg "$parse_errors"
    fi

    return 0
}

# awsprof_cmd_check - Read and output .awsprofile file from current directory
awsprof_cmd_check() {
    local profile_name
    profile_name=$(awsprof_util_read_awsprofile)

    # Output the profile name (or empty string if not found)
    # This outputs to stdout for use in tests and by shell integration
    echo "$profile_name"

    return 0
}

#=== SHELL INTEGRATION ===
# awsprof_hook_detect_profile - Hook for PROMPT_COMMAND to detect profile mismatches
# awsprof_cmd_init - Initialize shell integration

awsprof_hook_detect_profile() {
    # This is a stub for the detection hook that will be called from PROMPT_COMMAND
    # Future stories (3.4-3.6) will implement the actual detection logic
    # For now, this is just a placeholder that does nothing
    :
}

# awsprof_cmd_init - Output bash or POSIX sh shell initialization code
awsprof_cmd_init() {
    # Check for --sh flag to output POSIX sh compatible code
    local shell_mode="bash"
    if [[ "${1:-}" == "--sh" ]]; then
        shell_mode="sh"
        shift  # Remove --sh from arguments
    fi

    # Validate no extra arguments after flag processing
    if [[ $# -gt 0 ]]; then
        awsprof_error "init command takes no arguments"
        return 1
    fi

    # Output BASH shell code (default behavior)
    if [[ "$shell_mode" == "bash" ]]; then
        cat <<INIT_SCRIPT
# awsprof shell integration - source this in your ~/.bashrc
# Usage: eval "\$(awsprof init)"

# Define the detection hook function (stub for now, will be enhanced in future stories)
awsprof_hook_detect_profile() {
    # Stub function for PROMPT_COMMAND hook
    # Future stories will implement:
    # - Check for .awsprofile file in current directory
    # - Compare expected profile vs current AWS_PROFILE
    # - Display warnings and prompts if mismatch detected
    :
}

# Define wrapper function that properly handles environment variables
# Uses 'command awsprof' to find the actual executable, not the function
# IMPORTANT: Only eval output from commands that produce shell code (use, check)
# For informational commands (list, whoami, help), call awsprof directly
awsprof() {
    local cmd="\${1:-}"
    # Only use eval wrapper for commands that output shell code
    if [[ "\$cmd" == "use" || "\$cmd" == "check" ]]; then
        eval "\$(command awsprof "\$@")"
    else
        # For other commands, just execute them directly
        command awsprof "\$@"
    fi
}

# Set up PROMPT_COMMAND hook for directory change detection
if [[ -z "\$PROMPT_COMMAND" ]]; then
    PROMPT_COMMAND='awsprof_hook_detect_profile'
else
    # Append to existing PROMPT_COMMAND without duplicating
    if [[ "\$PROMPT_COMMAND" != *"awsprof_hook_detect_profile"* ]]; then
        PROMPT_COMMAND="\${PROMPT_COMMAND%;};awsprof_hook_detect_profile"
    fi
fi

INIT_SCRIPT
    fi

    # Output POSIX SH compatible code
    if [[ "$shell_mode" == "sh" ]]; then
        cat <<'INIT_SCRIPT_SH'
# awsprof shell integration for POSIX sh - source this in your ~/.profile
# Usage: eval "$(awsprof init --sh)"

# Define wrapper function that properly handles environment variables
# Uses 'command awsprof' to find the actual executable, not the function
# Note: POSIX sh uses backticks for maximum compatibility
# IMPORTANT: Only eval output from commands that produce shell code (use, check)
# For informational commands (list, whoami, help), call awsprof directly
awsprof() {
    cmd="${1:-}"
    # Only use eval wrapper for commands that output shell code
    if [ "$cmd" = "use" ] || [ "$cmd" = "check" ]; then
        eval "`command awsprof "$@"`"
    else
        # For other commands, just execute them directly
        command awsprof "$@"
    fi
}

# LIMITATION: Automatic profile detection is NOT available in POSIX sh
# (POSIX sh lacks shell hooks available in bash - no event system)
# To check your profile, run: awsprof check
# Or manually verify with: echo $AWS_PROFILE

INIT_SCRIPT_SH
    fi

    return 0
}

#=== MAIN DISPATCH ===
# Main command dispatcher

# If script is sourced (for testing), don't run main
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-}" in
        list)
            awsprof_cmd_list
            exit $?
            ;;
        use)
            awsprof_cmd_use "${2:-}" "${3:-}"
            exit $?
            ;;
        whoami)
            awsprof_cmd_whoami
            exit $?
            ;;
        add)
            awsprof_cmd_add "${2:-}" "${3:-}"
            exit $?
            ;;
        edit)
            awsprof_cmd_edit "${2:-}" "${3:-}"
            exit $?
            ;;
        remove)
            awsprof_cmd_remove "${2:-}" "${3:-}"
            exit $?
            ;;
        import)
            awsprof_cmd_import
            exit $?
            ;;
        check)
            awsprof_cmd_check
            exit $?
            ;;
        init)
            awsprof_cmd_init ${2:-}
            exit $?
            ;;
        help|--help|-h|"")
            awsprof_msg "awsprof v${_awsprof_version}"
            awsprof_msg "Usage: awsprof <command>"
            awsprof_msg ""
            awsprof_msg "Commands:"
            awsprof_msg "  list              List available AWS profiles"
            awsprof_msg "  use <profile>     Switch to a profile (use with eval)"
            awsprof_msg "  whoami            Show currently active profile"
            awsprof_msg "  add <profile>     Add a new AWS profile"
            awsprof_msg "  edit <profile>    Edit an existing AWS profile"
            awsprof_msg "  remove <profile>  Remove an AWS profile"
            awsprof_msg "  import            Import profiles from credentials file"
            awsprof_msg "  check             Check .awsprofile file in current directory"
            awsprof_msg "  init              Initialize shell integration (use with eval)"
            exit 0
            ;;
        *)
            awsprof_error "Unknown command: ${1}"
            exit 1
            ;;
    esac
fi
