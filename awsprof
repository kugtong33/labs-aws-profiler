#!/usr/bin/env bash
#
# awsprof - AWS Profile Manager
# https://github.com/kugtong33/labs-aws-profiler
#

# Only set strict mode when running as script, not when sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    set -euo pipefail
fi

#=== CONFIGURATION ===
_awsprof_version="0.1.1"
_awsprof_credentials="${AWS_SHARED_CREDENTIALS_FILE:-$HOME/.aws/credentials}"
_awsprof_config="${AWS_CONFIG_FILE:-$HOME/.aws/config}"
AWSPROF_EMOJI="${AWSPROF_EMOJI:-0}"

#=== OUTPUT UTILITIES ===
# awsprof_msg - Output message to stderr
# awsprof_error - Output error message to stderr
# awsprof_warn - Output warning message to stderr
# awsprof_success - Output success message to stderr

awsprof_msg() {
    echo "$*" >&2
}

awsprof_error() {
    awsprof_msg "Error: $*"
}

awsprof_warn() {
    awsprof_msg "Warning: $*"
}

awsprof_success() {
    awsprof_msg "$*"
}

#=== INI HANDLING ===
# awsprof_ini_list_sections - List all profile sections from credentials file
# awsprof_ini_read_section - Read key-value pairs from a specific section

awsprof_ini_list_sections() {
    local file="${1:-$_awsprof_credentials}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Extract section names using awk
    local errexit_was_set=0
    [[ $- == *e* ]] && errexit_was_set=1
    set +e
    awk '
        /^\[/ {
            if ($0 !~ /^\[[^][]+\]$/) {
                print "Error: Malformed INI section header at line " NR ": " $0 > "/dev/stderr"
                exit 2
            }
            gsub(/^\[|\]$/, "")
            print
        }
    ' "$file"
    local awk_status=$?
    if [[ $errexit_was_set -eq 1 ]]; then
        set -e
    fi
    if [[ $awk_status -ne 0 ]]; then
        if [[ $awk_status -ne 2 ]]; then
            awsprof_error "Failed to parse credentials file: $file"
        fi
        return 1
    fi

    return 0
}

awsprof_ini_read_section() {
    local section="$1"
    local file="${2:-$_awsprof_credentials}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        return 1
    fi

    # Read section content using awk
    local errexit_was_set=0
    [[ $- == *e* ]] && errexit_was_set=1
    set +e
    awk -F' *= *' -v section="[$section]" '
        /^\[/ {
            if ($0 !~ /^\[[^][]+\]$/) {
                print "Error: Malformed INI section header at line " NR ": " $0 > "/dev/stderr"
                exit 2
            }
            found = ($0 == section)
            next
        }
        found && $0 !~ /^[ \t]*($|[;#])/ && index($0, "=") == 0 {
            print "Error: Malformed INI key/value at line " NR ": " $0 > "/dev/stderr"
            exit 2
        }
        found && /^[^#;]/ && NF >= 2 {
            key = $1
            gsub(/^[ \t]+|[ \t]+$/, "", key)
            val = $2
            for (i = 3; i <= NF; i++) val = val "=" $i
            gsub(/^[ \t]+|[ \t]+$/, "", val)
            print key "=" val
        }
    ' "$file"
    local awk_status=$?
    if [[ $errexit_was_set -eq 1 ]]; then
        set -e
    fi
    if [[ $awk_status -ne 0 ]]; then
        if [[ $awk_status -ne 2 ]]; then
            awsprof_error "Failed to read section '$section' from: $file"
        fi
        return 1
    fi

    return 0
}

#=== FILE OPERATIONS ===
# awsprof_backup_credentials - Create timestamped backup of credentials file
# awsprof_ini_write_section - Write or update a section in INI file
# awsprof_ini_delete_section - Delete a section from INI file

awsprof_backup_credentials() {
    # Use AWS_SHARED_CREDENTIALS_FILE if set, otherwise default
    local file="${1:-${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}}"

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        return 1
    fi

    # Generate timestamp in YYYYMMDD-HHMMSS format
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_file="${file}.bak.${timestamp}"

    # Copy to backup
    if ! cp "$file" "$backup_file" 2>/dev/null; then
        awsprof_error "Failed to create backup: $backup_file"
        return 1
    fi

    return 0
}

awsprof_ini_write_section() {
    local section="$1"
    shift
    local kvpairs=("$@")

    local file="${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}"

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        return 1
    fi

    local dir
    dir=$(dirname "$file")
    local temp_file
    temp_file=$(mktemp -p "$dir" ".awsprof.XXXXXX") || {
        awsprof_error "Failed to create temp file in: $dir"
        return 1
    }

    local crlf=0
    if [[ -f "$file" ]] && LC_ALL=C grep -q $'\r' "$file"; then
        crlf=1
    fi

    # Build awk script for section write
    local awk_script='
    BEGIN {
        section_header = "[" section "]"
        in_target = 0
        found = 0
        wrote = 0
        split(kvpairs, pairs, "\n")
    }
    /^\[/ {
        # If we were in target section, output new key-value pairs
        if (in_target && wrote == 0) {
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
            wrote = 1
        }
        # Check if this is our target section
        in_target = ($0 == section_header)
        if (in_target) {
            found = 1
            print
        } else {
            print
        }
        next
    }
    # Skip old key-value pairs in target section
    in_target {
        if ($0 ~ /^[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*=/) next
        print
        next
    }
    # Print everything else
    { print }
    END {
        # If section was never found, append it
        if (found == 0) {
            print ""
            print section_header
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
        } else if (found == 1 && wrote == 0) {
            for (i in pairs) {
                if (pairs[i] != "") print pairs[i]
            }
        }
    }
    '

    # Convert kvpairs array to newline-separated string
    local kvpairs_str=""
    for pair in "${kvpairs[@]}"; do
        kvpairs_str="${kvpairs_str}${pair}"$'\n'
    done

    # Run awk to create new file content
    if [[ -f "$file" ]]; then
        if ! awk -v section="$section" -v kvpairs="$kvpairs_str" "$awk_script" "$file" > "$temp_file"; then
            awsprof_error "Failed to write section '$section' to temp file"
            rm -f "$temp_file"
            return 1
        fi
    else
        # Create new file with section
        echo "[$section]" > "$temp_file"
        for pair in "${kvpairs[@]}"; do
            echo "$pair" >> "$temp_file"
        done
    fi

    if [[ $crlf -eq 1 ]]; then
        if ! sed -e 's/\r$//' -e 's/$/\r/' "$temp_file" > "${temp_file}.crlf"; then
            awsprof_error "Failed to normalize CRLF line endings"
            rm -f "$temp_file" "${temp_file}.crlf"
            return 1
        fi
        mv "${temp_file}.crlf" "$temp_file" || {
            awsprof_error "Failed to update temp file with CRLF"
            rm -f "$temp_file" "${temp_file}.crlf"
            return 1
        }
    fi

    if ! chmod 600 "$temp_file" 2>/dev/null; then
        awsprof_error "Failed to set permissions on temp file"
        rm -f "$temp_file"
        return 1
    fi

    # Create backup if file exists
    if [[ -f "$file" ]]; then
        awsprof_backup_credentials "$file" || {
            rm -f "$temp_file"
            return 1
        }
    fi

    # Atomic move
    if ! mv "$temp_file" "$file" 2>/dev/null; then
        awsprof_error "Failed to write credentials file: $file"
        rm -f "$temp_file"
        return 1
    fi

    return 0
}

awsprof_ini_delete_section() {
    local section="$1"
    local file="${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}"

    # Check if section parameter provided
    if [[ -z "$section" ]]; then
        awsprof_error "Section name required"
        return 1
    fi

    # Check if file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "Credentials file not found: $file"
        rm -f "$temp_file"
        return 1
    fi

    local dir
    dir=$(dirname "$file")
    local temp_file
    temp_file=$(mktemp -p "$dir" ".awsprof.XXXXXX") || {
        awsprof_error "Failed to create temp file in: $dir"
        return 1
    }

    local crlf=0
    if LC_ALL=C grep -q $'\r' "$file"; then
        crlf=1
    fi

    # Awk script to remove section
    # Delete section header and its key=value lines
    if ! awk -v section="[$section]" '
        BEGIN { in_target = 0; seen_kv = 0 }
        /^\[/ {
            if ($0 == section) {
                in_target = 1
                seen_kv = 0
                next
            }
            in_target = 0
            seen_kv = 0
            print
            next
        }
        in_target {
            if ($0 ~ /^[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*=/) {
                seen_kv = 1
                next
            }
            if ($0 ~ /^$/ || $0 ~ /^[;#]/) {
                if (seen_kv == 1) {
                    in_target = 0
                    print
                }
                next
            }
            next
        }
        { print }
    ' "$file" > "$temp_file"; then
        awsprof_error "Failed to delete section '$section' to temp file"
        rm -f "$temp_file"
        return 1
    fi

    if [[ $crlf -eq 1 ]]; then
        if ! sed -e 's/\r$//' -e 's/$/\r/' "$temp_file" > "${temp_file}.crlf"; then
            awsprof_error "Failed to normalize CRLF line endings"
            rm -f "$temp_file" "${temp_file}.crlf"
            return 1
        fi
        mv "${temp_file}.crlf" "$temp_file" || {
            awsprof_error "Failed to update temp file with CRLF"
            rm -f "$temp_file" "${temp_file}.crlf"
            return 1
        }
    fi

    if ! chmod 600 "$temp_file" 2>/dev/null; then
        awsprof_error "Failed to set permissions on temp file"
        rm -f "$temp_file"
        return 1
    fi

    # Create backup
    awsprof_backup_credentials "$file" || {
        rm -f "$temp_file"
        return 1
    }

    # Atomic move
    if ! mv "$temp_file" "$file" 2>/dev/null; then
        awsprof_error "Failed to write credentials file: $file"
        rm -f "$temp_file"
        return 1
    fi

    return 0
}

#=== UTILITY FUNCTIONS ===
# awsprof_util_read_awsprofile_path - Read .awsprofile file from provided path
# awsprof_util_read_awsprofile - Read nearest .awsprofile within git repo
# awsprof_util_read_global_awsprofile - Read global .awsprofile file from ~/.aws
#
# awsprof_util_is_valid_profile_name - Validate profile name for shell-safe export

awsprof_util_read_awsprofile_path() {
    local profile_file="$1"

    if [[ -z "$profile_file" ]]; then
        return 0
    fi

    # Check if file exists
    if [[ ! -f "$profile_file" ]]; then
        return 0  # Return empty/success for missing file (silent failure)
    fi

    # Read first non-empty line, trim whitespace, and output to stdout
    local line trimmed
    while IFS= read -r line || [[ -n "$line" ]]; do
        trimmed="${line#"${line%%[![:space:]]*}"}"
        trimmed="${trimmed%"${trimmed##*[![:space:]]}"}"
        trimmed="${trimmed%%[[:space:]]#*}"
        trimmed="${trimmed%%[[:space:]];*}"
        trimmed="${trimmed%"${trimmed##*[![:space:]]}"}"
        if [[ -z "$trimmed" ]]; then
            continue
        fi
        if [[ "$trimmed" == \#* ]] || [[ "$trimmed" == \;* ]]; then
            continue
        fi
        if [[ -n "$trimmed" ]]; then
            printf '%s\n' "$trimmed"
            break
        fi
    done < "$profile_file"

    return 0
}

awsprof_util_read_awsprofile() {
    local dir="$PWD"
    local found_profile=""

    if [[ -e "./.git" && -f "./.awsprofile" ]]; then
        awsprof_util_read_awsprofile_path "./.awsprofile"
        return 0
    fi

    while :; do
        if [[ -z "$found_profile" && -f "$dir/.awsprofile" ]]; then
            found_profile="$dir/.awsprofile"
        fi
        if [[ -e "$dir/.git" ]]; then
            if [[ -n "$found_profile" ]]; then
                awsprof_util_read_awsprofile_path "$found_profile"
            fi
            return 0
        fi
        if [[ "$dir" == "/" ]]; then
            break
        fi
        dir="${dir%/*}"
        if [[ -z "$dir" ]]; then
            dir="/"
        fi
    done

    return 0
}

awsprof_util_read_global_awsprofile() {
    awsprof_util_read_awsprofile_path "$HOME/.aws/.awsprofile"
}

awsprof_util_is_valid_profile_name() {
    local profile_name="$1"
    [[ "$profile_name" =~ ^[A-Za-z0-9._-]+$ ]]
}

#=== PROFILE COMMANDS ===
# awsprof_cmd_list - List available profiles
# awsprof_cmd_use - Switch to a profile
# awsprof_cmd_whoami - Show current profile
# awsprof_cmd_add - Add a new profile
# awsprof_cmd_edit - Edit an existing profile
# awsprof_cmd_remove - Remove an existing profile
# awsprof_cmd_import - Import profiles from existing credentials file

awsprof_cmd_list() {
    local profiles
    profiles=$(awsprof_ini_list_sections) || return 1

    if [[ -z "$profiles" ]]; then
        awsprof_msg "No profiles found"
        return 0
    fi

    echo "$profiles"
    return 0
}

awsprof_cmd_use() {
    local profile_name="$1"
    local extra_arg="$2"

    # Validate parameter provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof use <profile-name>"
        return 1
    fi

    # Reject if extra arguments provided
    if [[ -n "$extra_arg" ]]; then
        awsprof_error "Too many arguments: expected profile name only"
        awsprof_msg "Usage: awsprof use <profile-name>"
        return 1
    fi

    # Validate profile exists
    local profiles
    profiles=$(awsprof_ini_list_sections) || return 1

    if ! printf '%s\n' "$profiles" | grep -Fxq "$profile_name"; then
        awsprof_error "Profile '$profile_name' not found"
        return 1
    fi

    # Output eval code to stdout
    printf 'export AWS_PROFILE=%q\n' "$profile_name"

    # Output success message to stderr
    awsprof_success "Switched to profile: $profile_name"

    return 0
}

awsprof_cmd_whoami() {
    # Check if AWS_PROFILE is set and non-empty
    if [[ -n "${AWS_PROFILE:-}" ]]; then
        # Output current profile to stdout
        echo "$AWS_PROFILE"
    else
        # Output default message to stdout
        echo "No profile set (using default)"
    fi

    return 0
}

awsprof_cmd_add() {
    local profile_name="$1"
    local extra_arg="$2"

    # Validate profile name provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof add <profile-name>"
        return 1
    fi

    # Reject if extra arguments provided
    if [[ -n "$extra_arg" ]]; then
        awsprof_error "Too many arguments: expected profile name only"
        awsprof_msg "Usage: awsprof add <profile-name>"
        return 1
    fi

    # Check if profile already exists
    local profiles
    if ! profiles=$(awsprof_ini_list_sections); then
        return 1
    fi
    if printf '%s\n' "$profiles" | grep -Fxq "$profile_name"; then
        awsprof_error "Profile '$profile_name' already exists. Use 'awsprof edit' to modify."
        return 1
    fi

    # Prompt for credentials
    awsprof_msg "Adding new profile: $profile_name"
    local access_key_id
    local secret_access_key
    read -p "AWS Access Key ID: " access_key_id
    read -s -p "AWS Secret Access Key: " secret_access_key
    printf '\n' >&2  # Newline after hidden input

    # Validate credentials are not empty
    if [[ -z "$access_key_id" ]] || [[ -z "$secret_access_key" ]]; then
        awsprof_error "Access Key ID and Secret Access Key are required"
        return 1
    fi

    # Basic format validation
    if [[ ! "$access_key_id" =~ ^(AKIA|ASIA)[A-Z0-9]{16}$ ]]; then
        awsprof_error "Invalid Access Key ID format"
        return 1
    fi
    if [[ ! "$secret_access_key" =~ ^[A-Za-z0-9/+=]{40}$ ]]; then
        awsprof_error "Invalid Secret Access Key format"
        return 1
    fi

    # Write profile using Story 2.1 function
    if ! awsprof_ini_write_section "$profile_name" \
        "aws_access_key_id=$access_key_id" \
        "aws_secret_access_key=$secret_access_key"; then
        awsprof_error "Failed to add profile"
        return 1
    fi

    # Success message
    awsprof_success "Profile '$profile_name' added successfully"

    return 0
}

# awsprof_cmd_edit - Edit an existing profile
awsprof_cmd_edit() {
    local profile_name="$1"
    local extra_arg="$2"

    # Validate profile name provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof edit <profile-name>"
        return 1
    fi

    # Reject if extra arguments provided
    if [[ -n "$extra_arg" ]]; then
        awsprof_error "Too many arguments: expected profile name only"
        awsprof_msg "Usage: awsprof edit <profile-name>"
        return 1
    fi

    # Check if profile exists
    local profiles
    if ! profiles=$(awsprof_ini_list_sections); then
        return 1
    fi
    if ! printf '%s\n' "$profiles" | grep -Fxq "$profile_name"; then
        awsprof_error "Profile '$profile_name' not found"
        return 1
    fi

    # Prompt for credentials
    awsprof_msg "Editing profile: $profile_name"
    local access_key_id
    local secret_access_key
    read -p "AWS Access Key ID: " access_key_id
    read -s -p "AWS Secret Access Key: " secret_access_key
    printf '\n' >&2  # Newline after hidden input

    # Validate credentials are not empty
    if [[ -z "$access_key_id" ]] || [[ -z "$secret_access_key" ]]; then
        awsprof_error "Access Key ID and Secret Access Key are required"
        return 1
    fi

    # Basic format validation
    if [[ ! "$access_key_id" =~ ^(AKIA|ASIA)[A-Z0-9]{16}$ ]]; then
        awsprof_error "Invalid Access Key ID format"
        return 1
    fi
    if [[ ! "$secret_access_key" =~ ^[A-Za-z0-9/+=]{40}$ ]]; then
        awsprof_error "Invalid Secret Access Key format"
        return 1
    fi

    # Write profile using Story 2.1 function
    if ! awsprof_ini_write_section "$profile_name" \
        "aws_access_key_id=$access_key_id" \
        "aws_secret_access_key=$secret_access_key"; then
        awsprof_error "Failed to update profile"
        return 1
    fi

    # Success message
    awsprof_success "Profile '$profile_name' updated successfully"

    return 0
}

# awsprof_cmd_remove - Remove an existing profile
awsprof_cmd_remove() {
    local profile_name="$1"
    local extra_arg="$2"

    # Validate profile name provided
    if [[ -z "$profile_name" ]]; then
        awsprof_error "Profile name required"
        awsprof_msg "Usage: awsprof remove <profile-name>"
        return 1
    fi

    # Reject if extra arguments provided
    if [[ -n "$extra_arg" ]]; then
        awsprof_error "Too many arguments: expected profile name only"
        awsprof_msg "Usage: awsprof remove <profile-name>"
        return 1
    fi

    # Check if profile exists
    local profiles
    if ! profiles=$(awsprof_ini_list_sections); then
        return 1
    fi
    if ! printf '%s\n' "$profiles" | grep -Fxq "$profile_name"; then
        awsprof_error "Profile '$profile_name' not found"
        return 1
    fi

    # Delete the profile using Story 2.1 function
    if ! awsprof_ini_delete_section "$profile_name"; then
        awsprof_error "Failed to remove profile"
        return 1
    fi

    # Success message
    awsprof_success "Profile '$profile_name' removed successfully"

    return 0
}

# awsprof_cmd_import - Import profiles from existing credentials file
awsprof_cmd_import() {
    local file="${AWS_SHARED_CREDENTIALS_FILE:-$_awsprof_credentials}"

    # Check if credentials file exists
    if [[ ! -f "$file" ]]; then
        awsprof_error "No credentials file found at $file"
        return 1
    fi

    # Get all profiles from credentials file (capture parse errors)
    local profiles
    local err_file
    err_file=$(mktemp) || {
        awsprof_error "Failed to create temp file for error capture"
        return 0
    }
    local list_status=0
    if profiles=$(awsprof_ini_list_sections "$file" 2>"$err_file"); then
        list_status=0
    else
        list_status=$?
    fi
    local parse_errors
    parse_errors=$(cat "$err_file" 2>/dev/null)
    rm -f "$err_file"

    # Count profiles and prepare output
    local profile_count
    if [[ -z "$profiles" ]]; then
        profile_count=0
    else
        profile_count=$(echo "$profiles" | wc -l)
    fi

    # Display results
    if [[ $profile_count -eq 0 ]]; then
        awsprof_msg "Found 0 profiles"
    else
        # Format profile list as space-separated string
        local profile_list
        profile_list=$(echo "$profiles" | tr '\n' ' ' | sed 's/ $//')
        awsprof_msg "Found $profile_count profiles: $profile_list"
        awsprof_success "All profiles are accessible to awsprof"
    fi

    if [[ $list_status -ne 0 ]] && [[ -n "$parse_errors" ]]; then
        awsprof_warn "Errors encountered while parsing credentials file:"
        awsprof_msg "$parse_errors"
    fi

    return 0
}

# awsprof_cmd_check - Read and output .awsprofile file from current directory
awsprof_cmd_check() {
    local profile_name
    profile_name=$(awsprof_util_read_awsprofile)

    # Output the profile name (or empty string if not found)
    # This outputs to stdout for use in tests and by shell integration
    echo "$profile_name"

    return 0
}

#=== SHELL INTEGRATION ===
# awsprof_prompt_switch_profile - Interactive prompt for profile switching
# awsprof_hook_detect_profile - Hook for PROMPT_COMMAND to detect profile mismatches
# awsprof_cmd_init - Initialize shell integration

awsprof_prompt_switch_profile() {
    # Interactive prompt to ask user if they want to switch profiles
    # Arguments: expected_profile_name
    # Returns: 0 (always)

    local expected_profile="$1"

    if [[ -z "$expected_profile" ]]; then
        return 0
    fi

    # Display prompt to stderr and capture user response
    # Use read without -p flag to avoid issues with redirected stdin
    printf "Switch profile? [y/N] " >&2
    local response
    if ! read response 2>/dev/null; then
        response=""
    fi

    # Parse response (case-insensitive yes)
    case "$response" in
        y|Y)
            # User wants to switch - execute profile switch via eval wrapper
            # awsprof_cmd_use outputs "export AWS_PROFILE=..." to stdout (for eval)
            # and success message to stderr (for user feedback)
            eval "$(awsprof_cmd_use "$expected_profile")" || true
            ;;
        *)
            # All other input (including 'n', 'N', empty) treated as no
            # Return silently
            :
            ;;
    esac

    return 0
}

awsprof_hook_detect_profile() {
    # Directory change detection hook for PROMPT_COMMAND
    # Checks for .awsprofile file and applies profile automatically when valid
    # Must complete quickly (under 10ms) and not affect shell performance

    # Get expected profile from project .awsprofile file (from Story 3.3 helper)
    local expected_profile
    expected_profile=$(awsprof_util_read_awsprofile 2>/dev/null) || expected_profile=""

    # If no project .awsprofile, fall back to global ~/.aws/.awsprofile
    if [[ -z "$expected_profile" ]]; then
        expected_profile=$(awsprof_util_read_global_awsprofile 2>/dev/null) || expected_profile=""
    fi

    # If still empty, exit silently (no expectation)
    if [[ -z "$expected_profile" ]]; then
        return 0
    fi

    # If already set, no work needed
    if [[ "${AWS_PROFILE:-}" == "$expected_profile" ]]; then
        return 0
    fi

    # Validate profile exists; warn/clear on missing credentials or parse errors
    local profiles
    if ! profiles=$(awsprof_ini_list_sections 2>/dev/null); then
        awsprof_warn "Profile '$expected_profile' not found"
        printf 'unset AWS_PROFILE\n'
        return 0
    fi
    if ! awsprof_util_is_valid_profile_name "$expected_profile"; then
        awsprof_warn "Profile '$expected_profile' not found"
        printf 'unset AWS_PROFILE\n'
        return 0
    fi
    if ! printf '%s\n' "$profiles" | grep -Fxq "$expected_profile"; then
        awsprof_warn "Profile '$expected_profile' not found"
        printf 'unset AWS_PROFILE\n'
        return 0
    fi

    # Emit eval-safe export to stdout (no stderr noise for valid switches)
    printf 'export AWS_PROFILE=%q\n' "$expected_profile"

    return 0
}

# awsprof_cmd_init - Output bash or POSIX sh shell initialization code
awsprof_cmd_init() {
    # Check for --sh flag to output POSIX sh compatible code
    local shell_mode="bash"
    if [[ "${1:-}" == "--sh" ]]; then
        shell_mode="sh"
        shift  # Remove --sh from arguments
    fi

    # Validate no extra arguments after flag processing
    if [[ $# -gt 0 ]]; then
        awsprof_error "init command takes no arguments"
        return 1
    fi

    # Output BASH shell code (default behavior)
    if [[ "$shell_mode" == "bash" ]]; then
        cat <<INIT_SCRIPT
# awsprof shell integration - source this in your ~/.bashrc
# Usage: eval "\$(awsprof init)"

# Define the detection hook function (calls back into awsprof script)
awsprof_hook_detect_profile() {
    # Use resolved awsprof path when available; otherwise no-op to keep shell functional
    if [[ -n "\$awsprof_bin" ]] && [[ -x "\$awsprof_bin" ]]; then
        eval "\$("\$awsprof_bin" --hook-detect-profile)" || true
    fi
}

# Resolve awsprof executable path once at init time (prefer external binary over function)
awsprof_bin=\$(type -P awsprof 2>/dev/null || true)

# Define wrapper function that properly handles environment variables
# Uses resolved awsprof path when available; falls back to 'command awsprof'
# IMPORTANT: Only eval output from commands that produce shell code (use)
# For informational commands (list, whoami, help, check), call awsprof directly
awsprof() {
    local cmd="\${1:-}"
    local awsprof_exec=""
    if [[ -n "\$awsprof_bin" ]] && [[ -x "\$awsprof_bin" ]]; then
        awsprof_exec="\$awsprof_bin"
    else
        awsprof_exec=\$(type -P awsprof 2>/dev/null || true)
    fi
    if [[ -z "\$awsprof_exec" ]]; then
        printf "awsprof not found in PATH\n" >&2
        return 1
    fi
    # Only use eval wrapper for commands that output shell code
    if [[ "\$cmd" == "use" ]]; then
        eval "\$(command "\$awsprof_exec" "\$@")"
    else
        # For other commands, just execute them directly
        command "\$awsprof_exec" "\$@"
    fi
}

# Set up PROMPT_COMMAND hook for directory change detection
if [[ -z "\$PROMPT_COMMAND" ]]; then
    AWSPROF_SILENT_HOOK=1
    PROMPT_COMMAND='awsprof_hook_detect_profile'
else
    # Prepend to existing PROMPT_COMMAND without duplicating
    if [[ "\$PROMPT_COMMAND" != *"awsprof_hook_detect_profile"* ]]; then
        AWSPROF_SILENT_HOOK=1
        PROMPT_COMMAND="awsprof_hook_detect_profile;\${PROMPT_COMMAND#;}"
    fi
fi

INIT_SCRIPT
    fi

    # Output POSIX SH compatible code
    if [[ "$shell_mode" == "sh" ]]; then
        cat <<'INIT_SCRIPT_SH'
# awsprof shell integration for POSIX sh - source this in your ~/.profile
# Usage: eval "`awsprof init --sh`"

# Resolve awsprof executable path once at init time (for graceful missing-PATH handling)
awsprof_bin=`command -v awsprof 2>/dev/null || true`
if [ -n "$awsprof_bin" ] && [ ! -x "$awsprof_bin" ]; then
    awsprof_bin=""
fi

# Define wrapper function that properly handles environment variables
# Uses resolved awsprof path when available; falls back to 'command awsprof'
# Note: POSIX sh uses backticks for maximum compatibility
# IMPORTANT: Only eval output from commands that produce shell code (use)
# For informational commands (list, whoami, help, check), call awsprof directly
awsprof() {
    cmd="${1:-}"
    awsprof_exec=""
    if [ -n "$awsprof_bin" ] && [ -x "$awsprof_bin" ]; then
        awsprof_exec="$awsprof_bin"
    else
        awsprof_exec=`command -v awsprof 2>/dev/null || true`
        if [ -n "$awsprof_exec" ] && [ ! -x "$awsprof_exec" ]; then
            awsprof_exec=""
        fi
    fi
    if [ -z "$awsprof_exec" ]; then
        printf "awsprof not found in PATH\n" >&2
        return 1
    fi
    # Only use eval wrapper for commands that output shell code
    if [ "$cmd" = "use" ]; then
        eval "`command "$awsprof_exec" "$@"`"
    else
        # For other commands, just execute them directly
        command "$awsprof_exec" "$@"
    fi
}

# LIMITATION: Automatic profile detection is NOT available in POSIX sh
# (POSIX sh lacks shell hooks available in bash - no event system)
# To check your profile, run: awsprof check
# Or manually verify with: echo $AWS_PROFILE

INIT_SCRIPT_SH
    fi

    return 0
}

#=== MAIN DISPATCH ===
# Main command dispatcher

# If script is sourced (for testing), don't run main
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-}" in
        list)
            awsprof_cmd_list
            exit $?
            ;;
        use)
            awsprof_cmd_use "${2:-}" "${3:-}"
            exit $?
            ;;
        whoami)
            awsprof_cmd_whoami
            exit $?
            ;;
        add)
            awsprof_cmd_add "${2:-}" "${3:-}"
            exit $?
            ;;
        edit)
            awsprof_cmd_edit "${2:-}" "${3:-}"
            exit $?
            ;;
        remove)
            awsprof_cmd_remove "${2:-}" "${3:-}"
            exit $?
            ;;
        import)
            awsprof_cmd_import
            exit $?
            ;;
        check)
            awsprof_cmd_check
            exit $?
            ;;
        --hook-detect-profile)
            # Internal hook for testing/PROMPT_COMMAND
            awsprof_hook_detect_profile
            exit $?
            ;;
        init)
            awsprof_cmd_init "${@:2}"
            exit $?
            ;;
        help|--help|-h|"")
            awsprof_msg "awsprof v${_awsprof_version}"
            awsprof_msg "Usage: awsprof <command>"
            awsprof_msg ""
            awsprof_msg "Commands:"
            awsprof_msg "  list              List available AWS profiles"
            awsprof_msg "  use <profile>     Switch to a profile (use with eval)"
            awsprof_msg "  whoami            Show currently active profile"
            awsprof_msg "  add <profile>     Add a new AWS profile"
            awsprof_msg "  edit <profile>    Edit an existing AWS profile"
            awsprof_msg "  remove <profile>  Remove an AWS profile"
            awsprof_msg "  import            Import profiles from credentials file"
            awsprof_msg "  check             Check .awsprofile file in current directory (single line: profile name)"
            awsprof_msg "                   Example .awsprofile: client-acme (safe to commit)"
            awsprof_msg "  init              Initialize shell integration (use with eval)"
            exit 0
            ;;
        *)
            awsprof_error "Unknown command: ${1}"
            exit 1
            ;;
    esac
fi
